#import <Foundation/Foundation.h>
#import "utils.h"
#import "IOKit/IOKitLib.h"
#import "objcLogger.h"
#import <sys/stat.h>
#import "post_exp.h"

extern char **environ;

int runCommandv(const char *cmd, int argc, const char * const* argv, void (^unrestrict)(pid_t))
{
    pid_t pid;
    posix_spawn_file_actions_t *actions = NULL;
    posix_spawn_file_actions_t actionsStruct;
    int out_pipe[2];
    bool valid_pipe = false;
    posix_spawnattr_t *attr = NULL;
    posix_spawnattr_t attrStruct;

    valid_pipe = pipe(out_pipe) == 0;
    if (valid_pipe && posix_spawn_file_actions_init(&actionsStruct) == 0) {
        actions = &actionsStruct;
        posix_spawn_file_actions_adddup2(actions, out_pipe[1], 1);
        posix_spawn_file_actions_adddup2(actions, out_pipe[1], 2);
        posix_spawn_file_actions_addclose(actions, out_pipe[0]);
        posix_spawn_file_actions_addclose(actions, out_pipe[1]);
    }

    if (unrestrict && posix_spawnattr_init(&attrStruct) == 0) {
        attr = &attrStruct;
        posix_spawnattr_setflags(attr, POSIX_SPAWN_START_SUSPENDED);
    }

    int rv = posix_spawn(&pid, cmd, actions, attr, (char *const *)argv, environ);

    if (unrestrict) {
        unrestrict(pid);
        kill(pid, SIGCONT);
    }

    if (valid_pipe) {
        close(out_pipe[1]);
    }

    if (rv == 0) {
        if (valid_pipe) {
            char buf[256];
            ssize_t len;
            while (1) {
                len = read(out_pipe[0], buf, sizeof(buf) - 1);
                if (len == 0) {
                    break;
                }
                else if (len == -1) {
                    perror("posix_spawn, read pipe\n");
                }
                buf[len] = 0;
                printf("%s\n", buf);
            }
        }
        if (waitpid(pid, &rv, 0) == -1) {
            printf("ERROR: Waitpid failed\n");
        } else {
            printf("%s(%d) completed with exit status %d\n", __FUNCTION__, pid, WEXITSTATUS(rv));
        }

    } else {
        printf("%s(%d): ERROR posix_spawn failed (%d): %s\n", __FUNCTION__, pid, rv, strerror(rv));
        rv <<= 8; // Put error into WEXITSTATUS
    }
    if (valid_pipe) {
        close(out_pipe[0]);
    }
    return rv;
}

int util_runCommand(const char *cmd, ...)
{
    va_list ap, ap2;
    int argc = 1;

    va_start(ap, cmd);
    va_copy(ap2, ap);

    while (va_arg(ap, const char *) != NULL) {
        argc++;
    }
    va_end(ap);

    const char *argv[argc+1];
    argv[0] = cmd;
    for (int i=1; i<argc; i++) {
        argv[i] = va_arg(ap2, const char *);
    }
    va_end(ap2);
    argv[argc] = NULL;

    int rv = runCommandv(cmd, argc, argv, NULL);
    return WEXITSTATUS(rv);
}

const char* get_boothash(void) {
    io_registry_entry_t registryEntry = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/chosen");
    if (registryEntry == IO_OBJECT_NULL) {
        return NULL;
    }
    CFDataRef bootManifestHash = IORegistryEntryCreateCFProperty(registryEntry, CFSTR("boot-manifest-hash"), kCFAllocatorDefault, kNilOptions);
    if(!bootManifestHash) {
        return NULL;
    }
    
    IOObjectRelease(registryEntry);
    
    CFIndex length = CFDataGetLength(bootManifestHash) * 2 + 1;
    char *manifestHash = (char*)calloc(length, sizeof(char));
    
    int i = 0;
    for (i = 0; i<(int)CFDataGetLength(bootManifestHash); i++) {
        sprintf(manifestHash+i*2, "%02X", CFDataGetBytePtr(bootManifestHash)[i]);
    }
    manifestHash[i*2] = 0;
    
    CFRelease(bootManifestHash);
    
    return manifestHash;
}

static char* find_fakeroot(void) {
    NSString *boothash = [NSString stringWithUTF8String:get_boothash()];
    if (!boothash) {
        return NULL;
    }
    
    NSString *ppPath = [NSString stringWithFormat:@"/private/preboot/%@", boothash];
    NSError *error = nil;
    NSArray<NSString *> *candidateURLs = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:ppPath error:&error];
    if (!error) {
        for (NSString *candidatePath in candidateURLs) {
            if ([candidatePath.lastPathComponent hasPrefix:@"jb-"]) {
                char *ret = malloc(1024);
                strcpy(ret, [NSString stringWithFormat:@"%@/%@", ppPath, candidatePath].UTF8String);
                
                return ret;
            }
        }
    }
    return NULL;
}

static const char* gen_fakeroot(void) {
    NSString *letters = @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    NSMutableString *result = [NSMutableString stringWithCapacity:6];
    
    for (NSUInteger i = 0; i < 6; i++) {
        NSUInteger randomIndex = arc4random_uniform((uint32_t)[letters length]);
        unichar randomCharacter = [letters characterAtIndex:randomIndex];
        [result appendFormat:@"%C", randomCharacter];
    }
    
    NSString *boothash = [NSString stringWithUTF8String:get_boothash()];
    if (!boothash) {
        return NULL;
    }
    
    NSString *fakeroot = [NSString stringWithFormat:@"/private/preboot/%@/jb-%@", boothash, result];
    return fakeroot.UTF8String;
}

BOOL start_jbenv() {
    setenv("PATH", "/sbin:/bin:/usr/sbin:/usr/bin:/var/jb/sbin:/var/jb/bin:/var/jb/usr/sbin:/var/jb/usr/bin", 1);
    setenv("TERM", "xterm-256color", 1);
    
    NSString *jbpath = @"/var/jb";
    
    LOG(@"[*] remount preboot");
    if (util_runCommand("/sbin/mount", "-u", "-w", "/private/preboot", NULL)) {
        LOG(@"[-] failed to remount");
        return NO;
    }
    
    NSString *boothash_path = [NSString stringWithFormat:@"%s%s", "/private/preboot/", get_boothash()];
    LOG_FMT(@"[*] boothash_path %s", boothash_path.UTF8String);
    
    struct stat pathstat;
    if (stat(boothash_path.UTF8String, &pathstat) != 0) {
        perror("failed");
        LOG_FMT(@"[-] stat failed: %s\n", boothash_path.UTF8String);
        return NO;
    }
    
    uid_t ownerid = pathstat.st_uid;
    gid_t groupid = pathstat.st_gid;
    if (ownerid != 0 || groupid != 0) {
        if (chown(boothash_path.UTF8String, 0, 0) != 0) {
            perror("failed");
            LOG_FMT(@"[-] chown failed %s\n", boothash_path.UTF8String);
            return NO;
        }
    }
    
    mode_t permission = pathstat.st_mode & S_IRWXU;
    if (permission != 0755) {
        if (chmod(boothash_path.UTF8String, 0755) != 0) {
            perror("failed");
            LOG_FMT(@"[-] chmod failed %s\n", boothash_path.UTF8String);
            return NO;
        }
    }
    
    NSError *error = nil;
    NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:jbpath error:&error];
    
    if (!error) {
        if ([attributes[NSFileType] isEqualToString:NSFileTypeSymbolicLink]) {
            [[NSFileManager defaultManager] removeItemAtPath:jbpath error:&error];
        } else if ([attributes[NSFileType] isEqualToString:NSFileTypeDirectory]) {
            // wtf
            [[NSFileManager defaultManager] removeItemAtPath:jbpath error:&error];
        }
    }
    const char *fakeroot_path = find_fakeroot();
    if (!fakeroot_path) fakeroot_path = gen_fakeroot();
    
    error = nil;
    [[NSFileManager defaultManager] createDirectoryAtPath:[NSString stringWithUTF8String:fakeroot_path]
                                    withIntermediateDirectories:YES attributes:nil error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to create fakeroot %@, path: %@", error, [NSString stringWithUTF8String:fakeroot_path]);
    }
    
    NSString *procursus_path = [NSString stringWithFormat:@"%s/%s", fakeroot_path, "procursus"];
    NSString *jbinstalled = [NSString stringWithFormat:@"%@/%s", procursus_path, ".jb_installed"];
    BOOL has_jb_installed = [[NSFileManager defaultManager] fileExistsAtPath:jbinstalled];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:jbinstalled]) {
        LOG(@"[*] .jb_installed is not existed");
    }
    
    error = nil;
    if (![[NSFileManager defaultManager] fileExistsAtPath:procursus_path]) {
        [[NSFileManager defaultManager] createDirectoryAtPath:procursus_path
                                        withIntermediateDirectories:YES attributes:nil error:&error];
        if (error) {
            LOG_FMT(@"[-] failed to create procursus path: %@", error);
            return NO;
        }
    }
    
    LOG_FMT(@"[*] procursus_path: %@", procursus_path);
    LOG_FMT(@"[*] jbinstalled: %@", jbinstalled);
    
    error = nil;
    if (![[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithFormat:@"%@/basebin", procursus_path]]) {
        [[NSFileManager defaultManager] createDirectoryAtPath:[NSString stringWithFormat:@"%@/basebin", procursus_path]
                                        withIntermediateDirectories:YES attributes:nil error:&error];
        if (error) {
            LOG_FMT(@"[-] failed to create basebin path: %@", error);
            return NO;
        }
    }
    
    error = nil;
    [[NSFileManager defaultManager] createSymbolicLinkAtPath:jbpath
                                    withDestinationPath:procursus_path error:&error];
    if (error) {
       LOG_FMT(@"[-] failed to symlink path: %@", error);
    }
    
    if (!has_jb_installed) {
        LOG(@"[*] extracting bootstrap");
        NSString *bootstrap_path = [NSString stringWithFormat:@"%@%s",
                                    NSBundle.mainBundle.bundlePath,
                                    "/bootstrap-iphoneos-arm64.tar"];
        NSString *binpack_path = [NSString stringWithFormat:@"%@%s",
                                    NSBundle.mainBundle.bundlePath,
                                    "/iosbinpack.tar"];
        NSString *tar_path = [NSString stringWithFormat:@"%@%@",
                                    NSBundle.mainBundle.bundlePath, @"/tar"];
        NSString *cp_path = [NSString stringWithFormat:@"%@%@",
                             NSBundle.mainBundle.bundlePath, @"iosbinpack64/bin/cp"];
        if (chmod(tar_path.UTF8String, 0777)) {
            LOG(@"[-] failed to chmod");
            return NO;
        }
        util_runCommand(tar_path.UTF8String, "--preserve-permissions", "-xvf",
                        binpack_path.UTF8String, "-C", NSBundle.mainBundle.bundlePath.UTF8String, NULL);
        util_runCommand(tar_path.UTF8String, "--strip-components=3", "--preserve-permissions", "-xvf",
                        bootstrap_path.UTF8String, "-C", "/var/jb", NULL);
        
    }
    LOG(@"[+] finished extracting bootstrap");
    
    BOOL start_jbd();

    if (!start_jbd()) {
        LOG(@"[-] failed to start jailbreakd");
        return NO;
    }
    LOG(@"[+] started jailbreakd");

    return YES;
}

BOOL start_jbd() {
    LOG(@"[*] starting jailbreakd");
    LOG(@"[*] installing basebin");
    NSError *error = nil;

    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/LaunchDaemons" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove LaunchDaemons: %@", error);
        error = nil;
    }
    mkdir("/var/jb/basebin/LaunchDaemons", 0755);
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/LaunchDaemons/com.xia0o0o0o.jailbreakd.plist" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove com.xia0o0o0o.jailbreakd.plist: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/com.xia0o0o0o.jailbreakd.plist", NSBundle.mainBundle.bundlePath] toPath:@"/var/jb/basebin/LaunchDaemons/com.xia0o0o0o.jailbreakd.plist" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy com.xia0o0o0o.jailbreakd.plist: %@", error);
        error = nil;
        return NO;
    }
    chown("/var/jb/basebin/LaunchDaemons/com.xia0o0o0o.jailbreakd.plist", 0, 0);
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/jailbreakd" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove jailbreakd: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/jailbreakd", NSBundle.mainBundle.bundlePath] toPath:@"/var/jb/basebin/jailbreakd" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy jailbreakd: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/jailbreakd", 0, 0)) {
        LOG(@"[-] failed to chown jailbreakd");
    }
    if (chmod("/var/jb/basebin/jailbreakd", 0755)) {
        LOG(@"[-] failed to chmod jailbreakd");
    }


    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/jbinit"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove jbinit: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/jbinit", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/jbinit" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy jbinit: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/jbinit", 0, 0)) {
        LOG(@"[-] failed to chown jbinit");
    }
    if (chmod("/var/jb/basebin/jbinit", 0755)) {
        LOG(@"[-] failed to chmod jbinit");
    }
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/jbctl"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove jbctl: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/jbctl", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/jbctl" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy jbctl: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/jbctl", 0, 0)) {
        LOG(@"[-] failed to chown jbctl");
    }
    if (chmod("/var/jb/basebin/jbctl", 0755)) {
        LOG(@"[-] failed to chmod jbctl");
    }
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/launchdhook.dylib"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove launchdhook.dylib: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/launchdhook.dylib", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/launchdhook.dylib" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy launchdhook.dylib: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/launchdhook.dylib", 0, 0)) {
        LOG(@"[-] failed to chown launchdhook.dylib");
    }
    if (chmod("/var/jb/basebin/launchdhook.dylib", 0755)) {
        LOG(@"[-] failed to chmod launchdhook.dylib");
    }
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/systemhook.dylib"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove systemhook.dylib: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/systemhook.dylib", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/systemhook.dylib" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy systemhook.dylib: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/systemhook.dylib", 0, 0)) {
        LOG(@"[-] failed to chown systemhook.dylib");
    }
    if (chmod("/var/jb/basebin/systemhook.dylib", 0755)) {
        LOG(@"[-] failed to chmod systemhook.dylib");
    }
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/rootlesshooks.dylib"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove rootlesshooks.dylib: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/rootlesshooks.dylib", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/rootlesshooks.dylib" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy rootlesshooks.dylib: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/rootlesshooks.dylib", 0, 0)) {
        LOG(@"[-] failed to chown rootlesshooks.dylib");
    }
    if (chmod("/var/jb/basebin/systemhook.dylib", 0755)) {
        LOG(@"[-] failed to chmod systemhook.dylib");
    }
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/opainject"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove opainject: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/opainject", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/opainject" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy opainject: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/opainject", 0, 0)) {
        LOG(@"[-] failed to chown opainject");
    }
    if (chmod("/var/jb/basebin/opainject", 0755)) {
        LOG(@"[-] failed to chmod opainject");
    }
    
    util_runCommand("/var/jb/basebin/jbinit", NULL);

    return YES;
}
